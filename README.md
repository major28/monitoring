# monitoring
Monitoring service with gRPC API

Комментарии по реализации:
1. Из-за требования к мониторингу одного сервиса через равные интервалы времени(значение выставляется в конфиге),  каждый сервис мониторится в отдельной горутине.
2. В рантайм не храним состояния, так как лучше сразу заложить кластеризацию и вынести работу с данными в СУБД. 
3. Архитектуру можно проектировать исходя из двух стратегий: первая стратегия заключается в том, чтобы заложиться заранее под рост количества сайтов для мониторинга, но тогда пренебрегаем хранением исторических данных; вторая стратегия заключается в том, чтобы хранить исторические данные, но многократный рост количества сайтов будет сильно деградировать систему из-за большого количества данных. Выберим первую стратегию, так как нет вводных данных про хранению и отдачу исторических данных.
4. Нет уточнения что имеется ввиду под доступностью сайта, для упрощения взял случай, когда сайт является доступным, если он ответил на HTTP запрос не более чем N миллисекунд(значение выставляется в конфиге) при последнем обходе и вернул HTTP код 200. Если надо отдавать какую то перцентиль за какой то последний промежуток времени, то надо хранить исторические данные, но от этой стратегии мы отказались выше.
5. Список сайтов для мониторинга храним в СУБД, чтобы в будущем иметь возможно динамически его обновлять без перезапуска серверов мониторинга, а подхватывать новый сервис на лету. 
6. Для идентификации пользователя используем систему логин/пароль(хранятся в СУБД). Предполагается, что они будут выдаваться клиентам перед пользованием сервиса для идентификации пользователя
7. Так как на данном этапе слишком много неопределенностей, то невозможно определить более рациональное решения для хранения данных. Для простоты взял MySQL, но если в будущем появятся требования к высоким нагрузкам и MySQL не будет справляться, то можно заменить на какое то in-memory хранилище, с периодической выгрузкой на диск, как вариант redis. 
8. В качестве менеджера зависимостей взял dep.
9. Все конфиги вынесены в файл config.yml, который должен лежать рядом с запускаемым приложением.

Не стал реализовывать следующий функционал: 
1. TLS/SSL шифрование 
2. Покрытие тестами
3. Полный graceful shutdown приложения
4. Автоматизацию по сборке приложения через make файл
5. Болле безопасную систему авторизации пользователей на базе OAuth2 
6. 


Для запуска приложения надо:
1. Установить MySQL и создать там базу данных. После накатить миграции из файла deploy/dump.sql.
2. Прописать в конфиге config.yml доступы к MySQL, порт на котором будет запускаться API, уровень логирования, периодичность мониторинга одного сервиса, таймаут после которого считаем, что сервис недоступен.
3. go build и запускаем бинарный файл с конфигом config.yml, который должен лежать рядом
